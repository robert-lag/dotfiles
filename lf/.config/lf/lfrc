#  _  __
# | |/ _|
# | | |_
# | |  _|
# | | |
# |_|_|
#

# --------------------------------------------------
# Basic vars {{{1
# --------------------------------------------------
set shell bash
set shellopts '-eu'
set ifs "\n"
set scrolloff 10
set icons true
set period 1
set hidden true
set mouse true

# }}}1

# --------------------------------------------------
# Custom Functions {{{1
# --------------------------------------------------

# General {{{2
cmd open ${{
    case $(file --mime-type "$f" -bL) in
        text/*|application/json) $EDITOR "$f";;
        application/x-sc) sc-im "$f";;
        application/x-freeplane) freeplane-java-11 "$f" ;;
        *) xdg-open "$f" & ;;
    esac
}}

cmd open-alternative ${{
	file_ext="${f##*.}"

	if [ "$file_ext" = "desktop" ]; then
		open-desktop-file "$f"
	else
		case $(file --mime-type "$f" -bL) in
			application/pdf) devour okular "$f" ;;
			image/*) devour gimp "$f" ;;
			text/html) firefox "$f" & ;;
			application/x-freeplane) freeplane-java-11 "$f" ;;
			*) $EDITOR "$f";;
		esac
	fi
}}

cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"

cmd mkfile $$EDITOR $1

cmd chmod ${{
  printf "Mode Bits: "
  read ans

  for file in "$fx"
  do
    chmod $ans $file
  done

  lf -remote 'send reload'
}}

# Fzf-finder and movement {{{2
cmd fzf-jump ${{
  res="$(find . -maxdepth 3 | fzf --header='Jump to location')"
  if [ -f "$res" ]; then
    cmd="select"
  elif [ -d "$res" ]; then
    cmd="cd"
  fi
  lf -remote "send $id $cmd \"$res\""
}}

# Cut files {{{2
# Add to cut/copied files
cmd cut-add %{{
    files=$(lf -remote load | tail -n +2)
    newline=$'\n'

    # change to $fx to add current file when no toggled
    # files exist.
    if [ -n "$files" ]; then
        new_files=$(echo "$files${newline}$fx" | sort | uniq)
    else
        new_files=$fx
    fi
    # remove empty lines from the file list, because they keep messing
    # up the selection.
    new_files=$(echo "$new_files" | sed --quiet -e '/^$/d' -e 'p')

    lf -remote "save${newline}move${newline}${new_files}${newline}"
    lf -remote "send $id unselect${newline}send $id sync"
}}

# Remove from cut/copied files
cmd cut-remove %{{
    files=$(lf -remote load)
    operation=$(echo "$files" | head -n1)

    if [ "$operation" != "move" ]; then
        lf -remote "send $id echoerr no files in cut list."
        exit 1
    fi

    files=$(echo "$files" | tail -n +2)
    newline=$'\n'

    # change to $fx to remove current file when no toggled
    # files exist.
    if [ -n "$files" ]; then
        # here we want all files in $files that aren't in $fx, making sure
        # that none of the entries in $fx are included, even when they aren't
        # in $files. To do this we concatenate $files and $fx (twice), printing
        # only the uniqe lines.
        new_files=$(echo "$files$newline$fx$newline$fx" | sort | uniq -u)
    else
        new_files=$files
    fi
    new_files=$(echo "$new_files" | sed --quiet -e '/^$/d' -e 'p')

    lf -remote "save${newline}move${newline}${new_files}${newline}"
    lf -remote "send $id unselect${newline}send $id sync"
}}

# Archive bindings {{{2
cmd unarchive ${{
	case "$f" in
		*.zip) unzip "$f" ;;
		*.tar.gz) tar -xzvf "$f" ;;
		*.tar.bz2) tar -xjvf "$f" ;;
		*.tar) tar -xvf "$f" ;;
		*) echo "Unsupported format" ;;
	esac
}}

cmd zip ${{
	apack "$(basename "$f").zip" "$(basename "$f")"
}}

# Trash files {{{2
cmd trash ${{
	files=$(printf "$fx" | tr '\n' ';')
	while [ "$files" ]; do
    # extract the substring from start of string up to delimiter.
    # this is the first "element" of the string.
    file=${files%%;*}

    trash-put "$(basename "$file")"
    # if there's only one element left, set `files` to an empty string.
    # this causes us to exit this `while` loop.
    # else, we delete the first "element" of the string from files, and move onto the next.
    if [ "$files" = "$file" ]; then
      files=''
    else
      files="${files#*;}"
    fi
  done
}}

cmd clear-trash %trash-empty

cmd restore-trash ${{
  trash-restore
}}

# Dragon drag-and-drop {{{2
cmd dragon %dragon-drag-and-drop --all --and-exit $fx
cmd dragon-stay %dragon-drag-and-drop --all $fx
cmd dragon-individual %dragon-drag-and-drop $fx
cmd dragon-cp %dragon-cp
cmd dragon-mv %dragon-mv
cmd dragon-dl %dragon-dl

# Create symlink {{{2
# To create a symlink first copy/cut a file and
# then use the create-symlink command:
#	- copy file: creates soft-link
#	- cut file: creates hard-link
cmd link %{{
	# Get all selected files and their current mode
	# (copy or move)
	load=$(lf -remote 'load')
	mode=$(echo "$load" | sed -n '1p')
	select_files_list=$(echo "$load" | sed '1d')

	if [ -z "$select_files_list" ]; then
		lf -remote "send $id echo no files to link"
		exit 0
	fi

	case "$mode" in
		# Symbolically copy mode is indicating a soft link
		copy) ln --symbolic --relative --target-directory . -- "$select_files_list";;
		# while a move mode is indicating a hard link
		move) ln --target-directory . -- "$select_files_list";;
	esac

	lf -remote "send clear"
}}

# Change window title to current directory {{{2
cmd on-cd &{{
    # '&' commands run silently in background (which is what we want here),
    # but are not connected to stdout.
    # To make sure our escape sequence still reaches stdout we pipe it to /dev/tty
	printf "\033]0; $(pwd | sed "s|$HOME|~|")\007" > /dev/tty
}}
on-cd

# Vim-like commands {{{2
cmd q quit
cmd wq quit

# }}}1

# --------------------------------------------------
# Bindings {{{1
# --------------------------------------------------

# Remove defaults {{{2
map m
map d

# Basic bindings {{{2
map ZZ quit
map <esc> quit
map . set hidden!
map md push :mkdir<space>
map mf push :mkfile<space>
map R reload
map x $$f
map X !$f
# map o &mimeopen $f
# map O $mimeopen --ask $f
map o open
map O open-alternative
map <c-o> open-alternative
map <enter> open

# To create a symlink first copy/cut a file and
# the use the create-symlink command:
#	- copy file: creates soft-link
#	- cut file: creates hard-link
map L link

# Mouse bindings {{{2
map <m-up> up
map <m-down> down
map <m-1> toggle
map <m-2> unselect
map <m-3> invert

# Rename {{{2
map A rename # at the very end
map r push A<c-u> # new rename
map I push A<c-a> # at the very beginning
map i push A<a-b><a-b><a-f> # before extention
map a push A<a-b> # after extention
map B bulkrename

# Wallpaper / lockscreen {{{2
map bg $setbg $f
map bl $set-lockscreen $f

# Archive bindings {{{2
map az zip
map au unarchive

# Trash/delete bindings {{{2
map DD delete
map dd trash
map tt trash
map tc clear-trash
map tr restore-trash
map ma cut-add
map mr cut-remove

# Dragon drag-and-drop {{{2
map dr dragon
map ds dragon-stay
map di dragon-individual
map dm dragon-mv
map dc dragon-cp
map dl dragon-dl

# Movement {{{2
map gf fzf-jump

# Directory shortcuts
map gh cd ~
map gb cd ~/.local/bin
map gB cd /usr/local/bin
map gc cd ~/.config
map gd cd ~/data/_user/Documents
map gD cd /dev
map gE cd /etc
map gi cd ~/data/_user/Pictures
map gl cd ~/.local
map gm cd /run/media
map gM cd /mnt
map gO cd /opt
map gp cd ~/data/_user/programming
map gr cd /
map gs cd ~/.local/share
map gS cd /srv
map gT cd /tmp
map gu cd ~/data/_user
map gU cd /usr
map gV cd /var
map g/ cd /
